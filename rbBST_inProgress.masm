#
# Library for Red-Black Binary Search Tree implementation of orderbook management
#
# Reference: https://en.wikipedia.org/wiki/Red%E2%80%93black_tree
#

proc.getNodePointer
  # Inputs:  [creation_counter, ...]
  # Outputs: [node_pointer, ...]
  # node_pointer = creation_counter * 3 + 1
  #
  # Comments: node_pointer >= 1.  Three items in memory: coordinate_word, order_word, and change flag
  #
  push.3 mul push.1 add  # Generate node_pointer
end

proc.getTotalNodes
  mem_load.0 push.2 sub 
end

proc.SaveCoordinate
  # Inputs: [node_pointer, coordinate_word, ...]
  # Output: [...]
  #
  # Comments: saves coordinate word to address node_pointer, 
  #
  mem_storew dropw # Save in RAM          [...]
end

proc.SaveOrder
  # Inputs: [node_pointer, order_word, ...]
  # Output: [...]
  #
  # Comments: saves order word to address node_pointer+1, 
  #
  push.1 add       # Set memory address   [node_pointer+1, order_word, ...]
  mem_storew dropw # Save in RAM          [...]
end

proc.SaveChangeFlag
  # Inputs: [node_pointer, ...]
  # Output: [...]
  #
  # Comments: saves order word to address node_pointer+1, 
  #
  push.1 swap      # Set change flag      [node_pointer, 1, ...]
  push.2 add       # Set memory address   [node_pointer+2, 1, ...]
  mem_store        # Save in RAM          [...]
end

proc.UpdateCoordinate
  # Inputs: [node_pointer, coordinate_word, ...]
  # Output: [...]
  #
  # Comments: saves coordinate word to address node_pointer, 
  #            Change flag is updated
  #
  dup exec.SaveChangeFlag
  exec.SaveCoordinate
end

proc.UpdateOrder
  # Inputs: [node_pointer, order_word, ...]
  # Output: [...]
  #
  # Comments: saves order word to address node_pointer+1. 
  #            Change flag is updated
  #
  dup exec.SaveChangeFlag
  exec.SaveOrder
end

proc.SaveNode
  # Inputs: [node_pointer, coordinate_word, order_word]
  # Output: saves coordinate word to address node_pointer, 
  # and order_word to address node_pointer+1
  #
  dup movdn.5 
  exec.SaveCoordinate
  exec.SaveOrder
end

proc.UpdateNode
  # Inputs: [node_pointer, coordinate_word, order_word]
  # Output: saves coordinate word to address node_pointer, 
  # and order_word to address node_pointer+1
  #
  dup movdn.5 
  exec.UpdateCoordinate
  exec.UpdateOrder
end

proc.InitTree
  # Inputs:  [...]
  # Outputs: [...]
  #
  # Comments: Initialized rbBST tree by creating a special first node
  # With color and parent pointer set to special value of 2
  # 
  push.0.0.0.0.0.0.0.2                         # [2,0,0,0,0,0,0,0, ...]
  push.0 exec.getNodePointer exec.SaveNode     
end

proc.getCoordinates
  # Inputs:  [node_pointer, ...]
  # Outputs: [color, Parent_pointer, L_child_pointer, R_child_pointer, ...]
  # 
  push.0.0.0.0 
  movup.4 mem_loadw             # Load node Coordinates from memory
end

proc.getColorFromCoordinates
  # Inputs:  [color, Parent_pointer, L_child_pointer, R_child_pointer, ...]
  # Outputs: [color, ...]
  # 
  movdn.3         # Move color to bottom of current word
  drop drop drop  # Drop unnecessary pointer data
end

proc.getChildrenFromCoordinates
  # Inputs:  [color, Parent_pointer, L_child_pointer, R_child_pointer, ...]
  # Outputs: [L_child_pointer, R_child_pointer, ...]
  # 
  drop drop
end

proc.getOrder
  # Inputs:  [node_pointer, ...]
  # Outputs: [quantity, price, time, orderID, ...]
  # 
  push.0.0.0.0 movup.4 push.1 add mem_loadw  # Load node Order from memory
end

proc.getChangeFlag
  # Inputs:  [node_pointer, ...]
  # Outputs: [change_flag, ...]
  #
  push.2 add mem_load
end

proc.LoadNode
  # Inputs: [node_pointer, ...]
  # Output: [coordinate_word, order_word]
  #
  dup exec.getOrder
  movup.4
  dup exec.getCoordinates
  movup.4 
  exec.getChangeFlag
end

proc.PrintAllNodesEssential
  # Inputs: [...]
  # Output: [N, coordinate_word_N, price_N, ..., 2, coordinate_word_2, price_2, 1, coordinate_word_3, price_3, ... ]
  #
  push.0 dup                            # [0,0,....]
  mem_load.0 lt                         # [isLessThanCreationNumber_bool, 0, ...]
  while.true
     push.1 add dup                     # [j++, j++, ...]
     exec.getNodePointer                # [node_pointer, j++, ...]
     dup exec.getOrder                  # [order_word, node_pointer, j++, ...]
     drop swap drop swap drop           # [order_price, node_pointer, j++, ...]
     swap exec.getCoordinates           # [coordinate_word, order_price, j++, ...]
     movup.5 dup                        # [j++, j++, coordinate_word, order_price, j++, ...]
     exec.getNodePointer swap           # [j++, node_pointer, coordinate_word, order_price, j++, ...]
     dup mem_load.0 lt                  # [moreNodes_bool, j++, node_pointer, coordinate_word, order_price, j++, ...]
  end
  drop
end

proc.PrintAllNodes
  # Inputs: [...]
  # Output: [N, coordinate_word_N, order_word_N, ..., 2, coordinate_word_2, order_word_2, 1, coordinate_word_3, order_word_3, ... ]
  #
  push.0 dup                            # [0,0,....]
  mem_load.0 lt                         # [isLessThanCreationNumber_bool, 0, ...]
  while.true
     push.1 add dup                     # [j++, j++, ...]
     exec.getNodePointer exec.LoadNode  # [node_change_flag, node_coordinate_word, node_order_word, j++, ...]
     drop movup.8 dup                   # [j++, j++, node_coordinate_word, node_order_word, ...]
     exec.getNodePointer swap           # [j++, node_pointer, node_coordinate_word, node_order_word, ...]
     dup mem_load.0 lt                  # [moreNodes_bool, j++, node_pointer, node_coordinate_word, node_order_word, ...]
  end
  drop
end

proc.PrintChangeLog
  # Inputs: [...]
  # Output: [N, coordinate_word_N, order_word_N, ..., 2, coordinate_word_2, order_word_2, 1, coordinate_word_3, order_word_3, ... ]
  #
  # Comments: Prints all node data only for orders whose change flag has changed
  #
  push.0 dup                           # [0,0,....]
  mem_load.0 lt                       # [isLessThanCreationNumber_bool, 0, ...]
  while.true
    push.1 add dup                     # [j++, j++, ...]
    exec.getNodePointer                # [node_pointer, j++, ...] 
    dup exec.getChangeFlag             # [node_change_flag, node_pointer, j++, ...]
    if.true 
      exec.LoadNode drop               # [node_coordinate_word, node_order_word, j++, ...]
      movup.8 dup                      # [j++, j++, node_coordinate_word, node_order_word, ...]
      exec.getNodePointer swap         # [j++, node_pointer, node_coordinate_word, node_order_word, ...]
    else 
      drop
    end                
    dup mem_load.0 lt                  # [moreNodes_bool, j++, node_pointer, node_coordinate_word, node_order_word, ...]
  end
  drop
end

proc.CompareOrders
  # Input:   [Order_word_A, Order_Word_B, ...]
  # Outputs: [compare_bool, ...]
  #
  # Comment: compare_bool = 0 (1) if Order_A < Order B (Order_A > Order B)
  #
  # Order_A > Order_B if ( (price_A > price_B) or ((price_A==price_B) and (time_A > time_B)) )
  #
  ### COMPARE PRICES ###
  dup.5                      # Duplicate Price_B  
  dup.2                      # Duplicate Price_A
  lt                         # Check Price_B < Price_A ?
  if.true                    # Price_B < Price_A
    dropw dropw push.1       # Push 1 to signal result Order_A > Order_B
  else
    dup.5 dup.2 neq          # Duplicate Price_B, Price_A, and check for equality
    if.true                  # Price_A < Price_B 
      dropw dropw push.0     # Push 0 to signal result Order_B > Order_A
    else                     # Price_A = Price_B
      dup.6 dup.3            # Duplicate Time_B and Time_A 
      lt                     # Check Time_B < Time_A ?
      if.true                # Time_B < Time_A
        dropw dropw push.1   # Push 1 to signal result Order_A > Order_B
      else                   # Time_B > Time_A
        dropw dropw push.0   # Push 0 to signal result Order_A < Order_B
      end 
    end 
  end 
end

proc.setLeftChildToParent
  # Inputs:  [Parent_pointer, New_Child_pointer, ...]
  # Outputs: [...]
  #
  # Comments: Whithin P_coordinates: L_child_pointer -> New_Child_pointer
  #
  dup exec.getCoordinates    # Duplicate P_pointer and load coordinates     [___, ___, Lchild_pointer, ___, parent_pointer, new_Lchild_pointer, ...]
  movup.5                    # Move new Lchild to the top of the stack      [new_Lchild_pointer, ___, ___, Lchild_pointer, ___, parent_pointer, ...]
  swap.3 drop                # Swap with old L_child pointer                [ ___, ___, new_Lchild_pointer, ___, parent_pointer, ...]       
  movup.4                    # Move P_pointer to the top of the stack       [parent_pointer,  ___, ___, new_Lchild_pointer, ___, ...]
  dup exec.SaveChangeFlag    # Save change flag                             [parent_pointer,  ___, ___, new_Lchild_pointer, ___, ...]
  exec.SaveCoordinate        # Save updated Parent coordinates              [...]
end

proc.setRightChildToParent
  # Inputs:  [Parent_pointer, New_Child_pointer, ...]
  # Outputs: [...]
  #
  # Comments: Whithin P_coordinates: L_child_pointer -> New_Child_pointer
  #
  dup exec.getCoordinates    # Duplicate P_pointer and load coordinates     [___, ___, ___, Rchild_pointer, parent_pointer, new_Lchild_pointer, ...]
  movup.5                    # Move new Rchild to the top of the stack      [new_child_pointer, ___, ___, ___, Rchild_pointer, parent_pointer, ...]
  swap.4 drop                # Swap with old Rchild pointer                 [___, ___, ___, new_child_pointer, parent_pointer, ...]       
  movup.4                    # Move P_pointer to the top of the stack       [parent_pointer,  ___, ___, ___, new_child_pointer, ...]
  dup exec.SaveChangeFlag    # Save change flag                             [parent_pointer,  ___, ___, ___, new_child_pointer, ...]
  exec.SaveCoordinate        # Save updated Parent coordinates              [...]
end

proc.UpdateChildInParent
  # Inputs: [Parent_pointer, Child_Pointer, ...]
  # Output: [...]
  #
  # Comments: Checks if child is L or R and updates the corresponding pointer
  #
  dup exec.SaveChangeFlag              # Save change flag              [Parent_pointer, Child_Pointer, ...]
  dup.1 exec.getOrder                  # Load child order              [child_order_word, Parent_pointer, Child_Pointer, ...]
  dup.4 exec.getOrder                  # Load parent order             [parent_order_word, child_order_word, Parent_pointer, Child_Pointer, ...]
  exec.CompareOrders                   # Compare Parent and Child      [isParentGreaterThanChild_bool, Parent_pointer, Child_Pointer, ...]
  if.true                              
    exec.setLeftChildToParent 
  else
    exec.setRightChildToParent
  end
end

proc.UpdateParentInChild
  # Inputs: [Parent_pointer, Child_Pointer, ...]
  # Output: [ ...]
  #
  # Comments:  Sets Parent_pointer as the new parent of Child 
  #
  dup.1 exec.SaveChangeFlag # Save change flag
  dup.1 exec.getCoordinates # Load Child coordinates                   [           ____, OLD_parent_pointer,               ____, ____, Parent_pointer, Child_Pointer, ...]
  movup.4                   # Move Parent_pointer to top of the stack  [ Parent_pointer,               ____, OLD_parent_pointer, ____,           ____, Child_Pointer, ...]
  swap.2 drop               # Update parent pointer                    [           ____,     Parent_pointer,               ____, ____,  Child_Pointer, ...]
  movup.4                   # Move Child_pointer to top of the stack   [  Child_Pointer,               ____,     Parent_pointer, ____,           ____, ...]
  exec.SaveCoordinate       # Save updated coordinates                 [ ...]  
end

proc.HasChildren
  # Inputs:  [ node_pointer, ...]
  # Outputs: [hasChildren_bool, ...]
  #
  # Comments: Returns terminal_bool=1 if node has children.
  # terminal_bool=0 otherwise
  #
  exec.getCoordinates
  exec.getChildrenFromCoordinates
  push.0 eq 
  if.true
    push.0 eq 
    if.true
      push.0
    else
      push.1
    end 
  else
    drop push.1
  end
end

proc.FindParent
  # Inputs:  [new_order_word, ...]
  # Outputs: [parent_node_pointer, new_order_wordA, ...]
  #
  push.1 exec.getNodePointer loc_store.3  # Initialize Temp Pointer To Tree Root   [new_order_word, ...]
  push.1                                  # Enter while loop                       [1, new_order_word, ...]
  while.true
    ### COMPARE ###
    dupw                      # Duplicate new order word                           [new_order_word, new_order_word, ...]
    loc_load.3 exec.getOrder  # Load Temp Parent Order                             [temp_order_word, new_order_word, new_order_word, ...]
    exec.CompareOrders        # Compare temp to new (returns 1 if parent>new)      [isTempOrderGreater_bool, new_order_word, ...]

    ### LOAD TEMP's CHILDREN ###
    loc_load.3 exec.getCoordinates       # Get coordinates of temp order           [temp_coordinate_word, isTempOrderGreater_bool, new_order_word, ...]
    exec.getChildrenFromCoordinates      # Get temp order child pointers           [temp_Lchild_pointer, temp_Rchild_pointer, isTempOrderGreater_bool, new_order_word, ...]

    movup.2                   # Get order compare back on top of stack             [isTempOrderGreater_bool, temp_Lchild_pointer, temp_Rchild_pointer, new_order_word, ...]
    if.true
      swap drop               # Isolate Left child pointer address                 [temp_Lchild_pointer, new_order_word, ...]
    else
      drop                   # Isolate Right child pointer address                 [temp_Rchild_pointer, new_order_word, ...]
    end

    dup push.0 neq            # Check if child is not NIL                          [isChildNotNIL_bool, temp_Xchild_pointer, new_order_word, ...]
    if.true
      loc_store.3             # Update temp parent pointer                         [new_order_word, ...]
      push.1                  # Continue while loop                                [1, new_order_word, ...]
    else
      drop push.0             # Child slot is empty. Insert node here              [0, new_order_word, ...]
    end
  end
  loc_load.3                  # Return proper parent in tree                       [temp_parent_pointer, new_order_word, ...]
end

proc.getParentPointer
  # Inputs:  [node_pointer, ...]
  # Outputs: [parent_pointer, ...]
  #
  # Comments: Gets parent pointer
  # 
  exec.getCoordinates          # Loads node coordinates       [___, parent_pointer, ___, ___, ...]
  drop swap drop swap drop     # Isolates Parent pointer      [parent_pointer, ...]
end

proc.getUnclePointer
  # Inputs:  [node_pointer, ...]
  # Outputs: [uncle_pointer, ...]
  #
  # Comments: Gets uncle pointer
  #
  exec.getParentPointer dup         # Retrieves parent pointer and dups  [     parent_pointer, parent_pointer, ...]
  exec.getParentPointer             # Retrieves pointer to grandparent   [grandparent_pointer, ...]
  exec.getCoordinates               # Loads grandparent coordinates      [____, ____, relatedA_pointer, relatedB_pointer, parent_pointer, ...]
  drop drop                         # Drop unnecessary fields            [relatedA_pointer, relatedB_pointer, parent_pointer, ...]
  movup.2 dup.1 eq                  # Check if relatedA=parent           [isAparent_bool, relatedA_pointer, relatedB_pointer, ...] 
  if.true
    drop                            # RelatedB is uncle              
  else
    swap drop                       # RelatedA is uncle
  end                               # [uncle_pointer,  ...]
end

proc.isNIL
  # Inputs:  [node_pointer, ...]
  # Outputs: [isNIL_bool, ...]
  #
  # Comments: Gets uncle pointer
  #  
  exec.getOrder                        # Load Order                       [order_quantity, order_price, order_time, order_index, ...] 
  push.0 eq                            # Is quantity zero                 [isQuantityZero_bool, order_price, order_time, order_index, ...]
  swap push.0 eq and                   # Are price&quantity zero          [isPriceQuantityZero_bool, order_time, order_index, ...]
  swap push.0 eq and                   # Are price&quantity&time zero     [isTimePriceQuantityZero_bool, order_index, ...]
  swap push.0 eq and                   # Are price&quantity&time&idx zero [isIdxTimePriceQuantityZero_bool, ...]
end

proc.getColor
  # Inputs:  [node_pointer, ...]
  # Outputs: [node_color, ...]
  #
  # Comments: Returns color of node at node_pointer
  #
  exec.getCoordinates exec.getColorFromCoordinates
end

proc.setColor
  # Inputs: [node_pointer, color_bool, ...]
  # Output: [...]
  #
  # Comments: Sets color of node addressed by node_pointer
  #           to the color specified by color_bool
  #
  dup exec.SaveChangeFlag    # Save change flag
  dup exec.getCoordinates    # Load node_pointer coordinates                   [  node_color,        ___, ___, ___, node_pointer, color_bool, ...]
  movup.5                    # Move color_bool to top of stack                 [color_bool, node_color, ___, ___, ___, node_pointer, ...]
  swap drop movup.4          # Swap colors and move node_pointer top of stack  [node_pointer, color_bool, ___, ___, ___, ...]
  exec.SaveCoordinate
end

proc.isRoot
  # Inputs:  [node_pointer, ...]
  # Outputs: [isRoot_bool, ...]
  #
  # Comments: Checks if node is root of the tree
  #
  exec.getParentPointer exec.getColor    # Get parent color      [parent_color, ...]
  push.2 eq                              # Is Color Init value 2 [isColorInit_bool,...]
end

proc.getRootPointer 
  push.0 exec.getNodePointer exec.getCoordinates exec.getChildrenFromCoordinates
  dup push.0 eq 
  if.true 
    drop 
  else 
    swap drop
  end
end

proc.isUncleNIL
  # Inputs:  [node_pointer, ...]
  # Outputs: [isUncleNIL_bool, ...]
  #
  # Comments: Checks if Uncle of node is NIL
  #
  exec.getUnclePointer exec.isNIL
end

proc.isLeftChild
  # Inputs:  [node_pointer, ...]
  # Outputs: [isLeftChild_bool]
  #
  # Comments: Checks if node is a Left child of its parent
  #
  dup exec.isRoot not            # Confirm node isn't root   [isRoot_bool, node_pointer, ...]
  if.true
    dup exec.getParentPointer    # Loads pointer to parent   [parent_pointer, node_pointer, ...]
    exec.getCoordinates          # Loads parent coordiantes  [___, ___, parent_Lchild_pointer, parent_Rchild_pointer, node_pointer, ...]
    drop drop swap drop          # Drop unnecessary fields   [parent_Lchild_pointer, node_pointer, ...]
    eq                           # Check if node is Lchild   [isLeftChild_bool]
  else
    drop push.0  
  end            
end

proc.DereferenceParent
  # Inputs:  [node_pointer, ...]
  # Outputs: [...]
  #
  # Comments: remove any reference of node from parent
  #
  dup exec.getParentPointer     # [parent_pointer, node_pointer, ...]
  dup exec.SaveChangeFlag
  push.0 swap                   # [parent_pointer, 0, node_pointer, ...]
  movup.2 exec.isLeftChild      # [isLeftChild_bool, parent_pointer, 0, ...]
  if.true 
    exec.setLeftChildToParent   # [...]
  else 
    exec.setRightChildToParent  # [...]
  end
end

proc.setToNIL
  # Inputs:  [node_pointer, ...]
  # Outputs: [...]
  #
  # Comments: Zeros out node fields
  #
  dup exec.DereferenceParent   # [node_pointer, ...]
  push.0.0.0.0.0.0.0.0         # [0, 0, 0, 0, 0, 0, 0, 0, node_pointer, ...]  
  movup.8                      # [node_pointer, 0, 0, 0, 0, 0, 0, 0, 0, ...]
  exec.UpdateNode              # [...] 
end

proc.getSiblingPointer
  # Inputs:  [node_pointer, ...]
  # Outputs: [sibling_pointer, ...]
  #
  # Comments: Gets sibling pointer
  #
  dup exec.isLeftChild                                 # Is Node left child?               [isNodeLeftChild_bool, node_pointer, ...]
  swap exec.getParentPointer                           # Parent pointer                    [parent_pointer, isNodeLeftChild_bool, ...] 
  exec.getCoordinates exec.getChildrenFromCoordinates  # Parent's children pointers        [parent_Lchild_pointer, parent_Rchild_pointer, isNodeLeftChild_bool, ...]
  movup.2                                              # isNodeLeftChild_bool top of stack [isNodeLeftChild_bool, parent_Lchild_pointer, parent_Rchild_pointer, ...]
  if.true
    drop                                               # Sibling is parent's right child   [parent_Rchild_pointer, ...]
  else
    swap drop                                          # Sibling is parent's left child    [parent_Lchild_pointer, ...]
  end
end

proc.getNephewsPointers
  # Inputs:  [node_pointer, ...]
  # Outputs: [close_nephew_pointer, distant_nephew_pointer, ...]
  #
  # Comments: Gets nephew pointers, close nephew first
  #
  dup exec.isLeftChild not                             # Is Node Right child?              [isNodeRightChild_bool, node_pointer, ...]
  swap exec.getSiblingPointer                          # Sibling pointer                   [sibling_pointer, isNodeRightChild_bool, ...] 
  exec.getCoordinates exec.getChildrenFromCoordinates  # Sibling's children pointers       [sibling_Lchild_pointer, sibling_Rchild_pointer, isNodeRightChild_bool, ...]
  dup.2                                                # isNodeLeftChild_bool top of stack [isNodeRightChild_bool, sibling_Lchild_pointer, sibling_Rchild_pointer, ...]
  if.true
    swap                                               # Sibling's Right child is close nephew [sibling_Rchild_pointer, sibling_Lchild_pointer, ...]
  end
  #### Else # Sibling's Left child is close nephew [sibling_Lchild_pointer, sibling_Rchild_pointer, ...]
end

proc.hasLeftChild
  # Inputs: [node_pointer,....]
  # Ouputs: [hasLeftChild_bool, Lchild_pointer...]
  #
  # Comments: Verifies if node has left child and returns pointer to it
  #  
  exec.getCoordinates     # Get coordinates 
  drop drop swap drop     # Isolate Left child pointer
  dup push.0 eq not       # Duplicate and chech that it isn't NIL
end

proc.isPointerInCoordinate
  # Inputs: [node_pointer, coordinate_word, ...]
  # Ouputs: [isPointerInCoordinate_bool, Position_in_coordinate_word...]
  #
  # Comments: Checks if pointer exists in coordinate word and returns bool alongside position in word
  #
  swap drop               # Get rid of color               [node_pointer, parent_pointer, Lchild_pointer, Rchild_pointer, ...]
  dup.1 dup.1 neq         # Is node not the parent?        [isNodeParent_bool, node_pointer, parent_pointer, Lchild_pointer, Rchild_pointer, ...]
  if.true
    swap drop             # Drop parent pointer            [node_pointer, Lchild_pointer, Rchild_pointer, ...]
    dup.1 dup.1 neq       # Is node not the Left child?    [isNodeNotLchild_bool, node_pointer, Lchild_pointer, Rchild_pointer, ...]
    if.true 
      swap drop           # Drop Left child                [node_pointer, Rchild_pointer, ...]
      neq                 # Is node not the Right child    [isNodeNotRchild_bool, ...]
      if.true 
        push.0.0          # Node not in coordinate word    [0, 0, ...]
      else 
        push.3 push.1     # Node is Right child            [1, 3, ...]
      end
    else 
      drop drop drop
      push.2 push.1       # Node is Left child             [1, 2, ...]
    end 
  else 
    drop drop drop drop
    push.1 push.1         # Node is Parent                 [1, 1, ...]
  end
end

proc.SwapIntoPositionKofFour
  # Inputs: [K, value, elem1, ..., elem4 ...]
  # Ouputs: [elem1, ..., elemK=value, ..., elem4 ...]
  #
  # Comments: Swaps 'value' into list of elements {elem1,...,elem4} at position 'K'.
  #           For proper functioning, K<4
  #

  loc_store.0             # Save K                 [value, elem1, elem2, ..., elemN ...]
  push.1 loc_load.0 eq 
  if.true
    swap drop 
  else 
    push.2 loc_load.0 eq
    if.true 
      swap.2 drop      
    else
      push.3 loc_load.0 eq
      if.true 
        swap.3 drop     
      else 
        swap.4 drop      # K must equal 4
      end 
    end
  end 
end

proc.UpdateParentReference
  # Inputs: [nodeA_pointer, nodeB_pointer, ...]
  # Ouputs: [nodeA_pointer, nodeB_pointer, ...]
  #
  # Comments: Updates nodeB to new child of nodeA's parent.
  #
  dup exec.getParentPointer       # Get nodeA's parent                   [nodeA_parent_pointer, nodeA_pointer, nodeB_pointer, ...]
  dup exec.SaveChangeFlag         # Switch parent change flag
  dup.2 swap                      # Prepare for new reference            [nodeA_parent_pointer, nodeB_pointer, nodeA_pointer, nodeB_pointer, ...]
  dup.2 exec.isLeftChild          # Is A a left child?                   [isLeftChild_bool, nodeA_parent_pointer, nodeB_pointer, nodeA_pointer, nodeB_pointer, ...]
  if.true 
    exec.setLeftChildToParent     # Update child in parent               [nodeA_pointer, nodeB_pointer, ...]
  else 
    exec.setRightChildToParent    # Update child in parent               [nodeA_pointer, nodeB_pointer, ...]
  end
end

proc.UpdateChildReferences
  # Inputs: [nodeA_pointer, nodeB_pointer, ...]
  # Ouputs: [nodeA_pointer, nodeB_pointer, ...]
  #
  # Comments: Updates nodeB as new parent of nodeA's children.
  #
  dup exec.getCoordinates         # Get nodeA coordinates                [nodeA_coordiante_word, nodeA_pointer, nodeB_pointer, ...] 
  exec.getChildrenFromCoordinates # Isolate children                     [nodeA_Lchild, nodeA_Rchild, nodeA_pointer, nodeB_pointer, ...]
  dup exec.SaveChangeFlag
  dup.1 exec.SaveChangeFlag       
  dup.3                           # Duplicate nodeB pointer on stack     [nodeB_pointer, nodeA_Lchild, nodeA_Rchild, nodeA_pointer, nodeB_pointer, ...]
  swap dup.1                      # ReDuplicate the same                 [nodeB_pointer, nodeA_Lchild, nodeB_pointer, nodeA_Rchild, nodeA_pointer, nodeB_pointer, ...]
  exec.UpdateParentInChild        # Reassign parent of nodeA_Lchild      [nodeB_pointer, nodeA_Rchild, nodeA_pointer, nodeB_pointer, ...]
  exec.UpdateParentInChild        # Reassign parent of nodeA_Rchild      [nodeA_pointer, nodeB_pointer, ...]
end

proc.SwapFamilyReferences
  # Inputs: [nodeA_pointer, nodeB_pointer, ...]
  # Ouputs: [...]
  #
  # Comments: Updates nodeB to new child of nodeA's parent, and parent of nodeA' children. AND viceversa
  #
  exec.UpdateParentReference      # [nodeA_pointer, nodeB_pointer, ...]
  exec.UpdateChildReferences      # [nodeA_pointer, nodeB_pointer, ...]
  swap                            # [nodeB_pointer, nodeA_pointer, ...]
  exec.UpdateParentReference      # [nodeB_pointer, nodeA_pointer, ...]
  exec.UpdateChildReferences      # [nodeB_pointer, nodeA_pointer, ...]
  swap                            # [nodeA_pointer, nodeB_pointer, ...]
end

proc.SwapNodes
  # Inputs: [nodeA_pointer, nodeB_pointer, ...]
  # Ouputs: [...]
  #
  # Comments: Swaps coordinates of two nodes.
  #

  exec.SwapFamilyReferences

  dup exec.SaveChangeFlag         # Save nodeA change flag
  dup.1 exec.SaveChangeFlag       # Save nodeB change flag

  dup exec.getCoordinates         # Get node A coordinates               [nodeA_coordinate_word, nodeA_pointer, nodeB_pointer, ...]
  dup.5                           # Duplicate nodeB pointer on stack     [nodeB_pointer, nodeA_coordinate_word, nodeA_pointer, nodeB_pointer, ...]
  exec.isPointerInCoordinate      # Is nodeB is in direct family of A?   [isDirectFamilyMember_bool, BinA_position, nodeA_pointer, nodeB_pointer, ...]
  if.true
    push.1 add                    # Add one to BinA for consistency      [BinA_position, nodeA_pointer, nodeB_pointer, ...]
    dup.2 exec.getCoordinates     # Get node B coordinates               [nodeB_coordinate_word, BinA_position, nodeA_pointer, nodeB_pointer, ...]
    dup.5                         # Duplicate node A pointer             [nodeA_pointer, nodeB_coordinate_word, BinA_position, nodeA_pointer, nodeB_pointer, ...]
    exec.isPointerInCoordinate    # Is nodeA is in direct family of B?   [isDirectFamilyMember_bool, AinB_position, BinA_position, nodeA_pointer, nodeB_pointer, ...]
    drop push.1 add               # Drop bool and fix AinB               [AinB_position, BinA_position, nodeA_pointer, nodeB_pointer, ...]

    dup.3 dup exec.getCoordinates # Get node B coordinates               [nodeB_coordinate_word, nodeB_pointer, AinB_position, BinA_position, nodeA_pointer, nodeB_pointer, ...]
    movup.4                       # Move nodeB_pointer top of stack      [nodeB_pointer, nodeB_coordinate_word, AinB_position, BinA_position, nodeA_pointer, nodeB_pointer, ...]
    movup.5                       # Move AinB to top of stack            [AinB_position, nodeB_pointer, nodeB_coordinate_word, BinA_position, nodeA_pointer, nodeB_pointer, ...]
    exec.SwapIntoPositionKofFour  # Get new nodeA coordinate word        [new_nodeA_coordinate_word, BinA_position, nodeA_pointer, nodeB_pointer, ...]
    movup.5                       # Bring nodeA pointer top of stack     [nodeA_pointer, new_nodeA_coordinate_word, BinA_position, nodeB_pointer, ...]
    dup exec.getCoordinates       # Get nodeA coordiante word            [nodeA_coordinate_word, nodeA_pointer, new_nodeA_coordinate_word, BinA_position, nodeB_pointer, ...]
    movup.9                       # Bring BinA top of stack              [BinA_position, nodeA_coordinate_word, nodeA_pointer, new_nodeA_coordinate_word, nodeB_pointer, ...]
    dup.5 swap                    # Duplicate nodeA pointer              [BinA_position, nodeA_pointer, nodeA_coordinate_word, nodeA_pointer, new_nodeA_coordinate_word, nodeB_pointer, ...]
    exec.SwapIntoPositionKofFour  # Get new nodeB coordinate word        [new_nodeB_coordinate_word, nodeA_pointer, new_nodeA_coordinate_word, nodeB_pointer, ...]
    movup.9                       # Bring nodeB pointer top of stack     [nodeB_pointer, new_nodeB_coordinate_word, nodeA_pointer, new_nodeA_coordinate_word, ...]
    exec.SaveCoordinate           # Save new Node B coordinates          [nodeA_pointer, new_nodeA_coordinate_word, ...]
    exec.SaveCoordinate           # Save new node A coordinates          [...]
  else
    drop                          # Drop unnecessary position            [nodeA_pointer, nodeB_pointer, ...]
    dup exec.getCoordinates       # Get node A coordinates               [nodeA_coordinate_word, nodeA_pointer, nodeB_pointer, ...]
    movup.5                       # Bring Node B pointer top of stack    [nodeB_pointer, nodeA_coordinate_word, nodeA_pointer, ...]
    dup exec.getCoordinates       # Get node B coordinates               [nodeB_coordinate_word, nodeB_pointer, nodeA_coordinate_word, nodeA_pointer, ...]
    movup.9                       # Bring node A pointer top of stack    [nodeA_pointer, nodeB_coordinate_word, nodeB_pointer, nodeA_coordinate_word, ...]
    exec.SaveCoordinate           # Save new Node A coordinates          [nodeB_pointer, nodeA_coordinate_word, ...]
    exec.SaveCoordinate           # Save new node B coordinates          [...]
  end
end

proc.getRightMinimumSubtreeElement
  # Inputs: [node_pointer,....]
  # Ouputs: [Minimum_Right_subtree_pointer, ...]
  #
  # Comments: Starting from the node N, function traverses left subtree 
  #           to find minimum subtree node Y.
  #
  dup exec.getCoordinates         # Get node coordinates                   [node_coordinate_word, node_pointer, ...]
  drop drop drop                  # Isolate Right child                    [Rchild_pointer, node_pointer, ...]
  swap drop push.1                # Enter while loop                       [1, Rchild_pointer, ...]

  while.true 
    dup exec.hasLeftChild         # Is there a left child?                 [hasLeftChild_bool, Lchild_pointer, in-order_successor_pointer, ...]
    if.true 
      swap drop                   # Left child is new in-order successor   [Lchild_pointer, ...]
      push.1                      # Continue loop                          [1, Lchild_pointer, ...]
    else 
      drop                        # Current in-order successor is final    [in-order_successor_pointer, ...]
      push.0                      # Exit while loop                        [0, in-order_successor_pointer, ...]
    end
  end
end

proc.LeftRotate
  # Inputs: [pivot_node_pointer,....]
  # Ouputs: [...]
  #
  # For spec readability, recall that the structure of each node's coordinates is:
  #
  # {color, parent_pointer, Left_child_pointer, Left_child_pointer}
  #
  # In what follows, coordinate values which remain unchanged are shown as an underscore (____)
  # 
  # <Coordinates Before>
  # Node's Parent (NP):                      {____,         ____,     N_pointer,        ____ } or {____, ____, ____ ,  N_pointer}
  # Node coordinates (N):                    {____,   NP_pointer,          ____, NRC_pointer }
  # Node's Right Child (NRC):                {____,    N_pointer, NRCLC_pointer,        ____ }
  # Node's Right Child's Left Child (NRCLC): {____,  NRC_pointer,          ____,        ____ }
  #
  # <Coordinates After>
  # Node's Parent (NP):                      {____,         ____,   NRC_pointer,          ____ }  or {____, ____, ____ ,  NRC_pointer}
  # Node coordinates (N):                    {____,  NRC_pointer,          ____, NRCLC_pointer }
  # Node's Right Child (NRC):                {____,   NP_pointer,     N_pointer,          ____ }
  # Node's Right Child's Left Child (NRCLC): {____,    N_pointer,          ____,          ____ }
  #
  # Visual for reference see here:
  # https://en.wikipedia.org/wiki/Red%E2%80%93black_tree#/media/File:Binary_Tree_Rotation_(animated).gif
  #

  #### UPDATE Node Parent (RP) ####
  dup exec.getCoordinates                # Load N's coordinates                   [____, NP_pointer,  ____, NRC_pointer, N_pointer, ...]
  drop swap drop                         # Isolate NP_pointer and NRC_pointer     [NP_pointer, NRC_pointer,   N_pointer, ...]
  dup.2 exec.isLeftChild                 # Is node left child?                    [isLeftChild_bool, NP_pointer, NRC_pointer,   N_pointer, ...]
  if.true 
    dup.1 dup.1 exec.setLeftChildToParent  # Update NRC as NP's new left child    [NP_pointer, NRC_pointer,   N_pointer, ...]
  else 
    dup.1 dup.1 exec.setRightChildToParent  # Update NRC as NP's new left child   [NP_pointer, NRC_pointer,   N_pointer, ...]
  end

  #### UPDATE Node's Right Child's Left Child (NRCLC) ####
  dup.1 exec.getCoordinates                    # Load NRC coordinates             [         ____,     N_pointer, NRCLC_pointer,       ____,    NP_pointer, NRC_pointer,   N_pointer, ...]
  exec.getChildrenFromCoordinates swap drop    # Isolate pointer to NRCLC         [NRCLC_pointer,    NP_pointer,   NRC_pointer,  N_pointer, ...]
  dup dup.4                                    # N and NRCLC on top of stack      [    N_pointer, NRCLC_pointer, NRCLC_pointer, NP_pointer, NRC_pointer, N_pointer, ...]
  exec.UpdateParentInChild                     # Set N as new parent of NRCLC     [NRCLC_pointer, NP_pointer, NRC_pointer, N_pointer, ...]

  #### UPDATE Node (N) ####
  dup.3 exec.getCoordinates              # Load N coordinates                     [         ____,  NP_pointer,        ____,   NRC_pointer, NRCLC_pointer,  NP_pointer, NRC_pointer, N_pointer, ...]
  movup.4                                # Move NRCLC_pointer top of stack        [NRCLC_pointer,        ____,  NP_pointer,          ____,   NRC_pointer,  NP_pointer, NRC_pointer, N_pointer, ...]
  swap.4 drop                            # Set NRCLC as right child of N          [         ____,  NP_pointer,        ____, NRCLC_pointer,    NP_pointer, NRC_pointer, N_pointer, ...]
  dup.5                                  # Duplicate NRC_pointer                  [  NRC_pointer,        ____,  NP_pointer,          ____, NRCLC_pointer,  NP_pointer, NRC_pointer, N_pointer, ...] 
  swap.2 drop                            # Set NRC as parent of N                 [         ____, NRC_pointer,        ____, NRCLC_pointer,    NP_pointer, NRC_pointer, N_pointer, ...]
  dup.6 exec.UpdateCoordinate            # Save new coordinates of N              [   NP_pointer, NRC_pointer,   N_pointer, ...]   

  #### UPDATE Node's Right Child (NRC) ####
  dup.1 exec.getCoordinates              # Load NRC coordinates                   [       ____,  N_pointer, NRCLC_pointer,      ____,  NP_pointer, NRC_pointer, N_pointer, ...]
  movup.4 swap.2 drop                    # Set NP as new parent of NRC            [       ____, NP_pointer, NRCLC_pointer,      ____, NRC_pointer,   N_pointer, ...]
  movup.5 swap.3 drop                    # Set N as new left child of NRC         [       ____, NP_pointer,     N_pointer,      ____, NRC_pointer, ...]
  movup.4 exec.UpdateCoordinate          # Save new coordinates of NRC            [ ...]
end

proc.RightRotate
  # Inputs: [pivot_node_pointer,....]
  # Ouputs: [...]
  #
  # For spec readability, recall that the structure of each node's coordinates is:
  #
  # {color, parent_pointer, Left_child_pointer, Left_child_pointer}
  #
  # In what follows, coordinate values which remain unchanged are shown as an underscore (____)
  # 
  # <Coordinates Before>
  # Root's Parent (NP):                      {____,         ____,     N_pointer,         ____ }  or {____, ____, ____ ,  N_pointer}
  # Root coordinates (N):                    {____,   NP_pointer,   NLC_pointer,         ____ }
  # Root's Left Child (NLC):                 {____,    N_pointer,          ____, NLCRC_pointer}
  # Root's Left Child's Right Child (NLCRC): {____,  NLC_pointer,          ____,         ____ }
  #
  # <Coordinates After>
  # Root's Parent (NP):                      {____,         ____,   NLC_pointer,         ____ }  or {____, ____, ____ ,  NLC_pointer}
  # Root coordinates (N):                    {____,  NLC_pointer, NLCRC_pointer,         ____ }
  # Root's Left Child (NLC):                 {____,   NP_pointer,          ____,     N_pointer}
  # Root's Left Child's Right Child (NLCRC): {____,    N_pointer,          ____,         ____ }
  #
  # Visual for reference see here:
  # https://en.wikipedia.org/wiki/Red%E2%80%93black_tree#/media/File:Binary_Tree_Rotation_(animated).gif
  #

  #### UPDATE Root Parent (NP) ####
  dup exec.getCoordinates                # Load N's coordinates                   [____,   NP_pointer,   NLC_pointer,  ____, N_pointer, ...]
  drop movup.2 drop                      # Isolate NP_pointer and NLC_pointer     [NP_pointer,   NLC_pointer,   N_pointer, ...]
  dup.2 exec.isLeftChild                 # Is node left child?                    [isLeftChild_bool, NP_pointer, NLC_pointer,   N_pointer, ...]
  if.true 
    dup.1 dup.1 exec.setLeftChildToParent  # Update NRC as NP's new left child    [NP_pointer, NLC_pointer,   N_pointer, ...]
  else 
    dup.1 dup.1 exec.setRightChildToParent  # Update NRC as NP's new left child   [NP_pointer, NLC_pointer,   N_pointer, ...]
  end

  #### UPDATE Root's Left Child's Right Child (NLCRC) ####
  dup.1 exec.getCoordinates              # Load NLC coordinates                   [         ____,     N_pointer,          ____, NLCRC_pointer,  NP_pointer, NRC_pointer,   N_pointer, ...]
  exec.getChildrenFromCoordinates drop   # Isolate pointer to NLCRC               [NLCRC_pointer,    NP_pointer,   NLC_pointer,     N_pointer, ...]
  dup dup.4                              # N and NLCRC pointer on stack           [    N_pointer, NLCRC_pointer, NLCRC_pointer,    NP_pointer, NLC_pointer,   N_pointer, ...]
  exec.UpdateParentInChild               # Set N as new parent of NLCRC           [NLCRC_pointer,    NP_pointer,   NLC_pointer,     N_pointer, ...]

  #### UPDATE Root (N) ####
  dup.3 exec.getCoordinates              # Load N coordinates                     [         ____,  NP_pointer,   NLC_pointer,          ____, NLCRC_pointer,  NP_pointer, NLC_pointer, N_pointer, ...]
  movup.4                                # Move NLCRC_pointer top of stack        [NLCRC_pointer,        ____,    NP_pointer,   NLC_pointer,          ____,  NP_pointer, NLC_pointer, N_pointer, ...]
  swap.3 drop                            # Set NLCRC as left child of N           [         ____,  NP_pointer, NLCRC_pointer,          ____,    NP_pointer, NLC_pointer,   N_pointer, ...]
  dup.5                                  # Duplicate NLC_pointer                  [  NLC_pointer,        ____,    NP_pointer, NLCRC_pointer,          ____,  NP_pointer, NLC_pointer, N_pointer, ...] 
  swap.2 drop                            # Set NLC as parent of N                 [         ____, NLC_pointer, NLCRC_pointer,          ____,    NP_pointer, NLC_pointer,   N_pointer, ...]
  dup.6 exec.UpdateCoordinate            # Save new coordinates of N              [NP_pointer, NLC_pointer, N_pointer, ...]   

  # #### UPDATE Root's Left Child (NLC) ####
  dup.1 exec.getCoordinates              # Load NLC coordinates                   [       ____,  N_pointer,       ____, NLCRC_pointer, NP_pointer, NLC_pointer, N_pointer, ...]
  movup.4 swap.2 drop                    # Set NP as new parent of NLC            [       ____, NP_pointer,       ____, NLCRC_pointer, NLC_pointer,   N_pointer, ...]
  movup.5 swap.4 drop                    # Set N as new right child of NLC        [       ____, NP_pointer,       ____,     N_pointer, NLC_pointer, ...]
  movup.4 exec.UpdateCoordinate          # Save new coordinates of NRC            [ ...]
end