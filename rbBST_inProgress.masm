#
# Library for Red-Black Binary Search Tree implementation of orderbook management
#
# Reference: https://en.wikipedia.org/wiki/Red%E2%80%93black_tree
#

proc.getNodePointer
  # Inputs:  [creation_counter, ...]
  # Outputs: [node_pointer, ...]
  # node_pointer = creation_counter * 3 + 1
  #
  # Comments: node_pointer >= 1.  Three items in memory: coordinate_word, order_word, and change flag
  #
  push.3 mul push.1 add  # Generate node_pointer
end

proc.getTotalNodes
  mem_load.0 push.2 sub 
end

proc.SaveCoordinate
  # Inputs: [node_pointer, coordinate_word, ...]
  # Output: [...]
  #
  # Comments: saves coordinate word to address node_pointer, 
  #
  mem_storew dropw # Save in RAM          [...]
end

proc.SaveOrder
  # Inputs: [node_pointer, order_word, ...]
  # Output: [...]
  #
  # Comments: saves order word to address node_pointer+1, 
  #
  push.1 add       # Set memory address   [node_pointer+1, order_word, ...]
  mem_storew dropw # Save in RAM          [...]
end

proc.SaveChangeFlag
  # Inputs: [node_pointer, ...]
  # Output: [...]
  #
  # Comments: saves order word to address node_pointer+1, 
  #
  push.1 swap      # Set change flag      [node_pointer, 1, ...]
  push.2 add       # Set memory address   [node_pointer+2, 1, ...]
  mem_store        # Save in RAM          [...]
end

proc.UpdateCoordinate
  # Inputs: [node_pointer, coordinate_word, ...]
  # Output: [...]
  #
  # Comments: saves coordinate word to address node_pointer, 
  #            Change flag is updated
  #
  dup exec.SaveChangeFlag
  exec.SaveCoordinate
end

proc.UpdateOrder
  # Inputs: [node_pointer, order_word, ...]
  # Output: [...]
  #
  # Comments: saves order word to address node_pointer+1. 
  #            Change flag is updated
  #
  dup exec.SaveChangeFlag
  exec.SaveOrder
end

proc.SaveNode
  # Inputs: [node_pointer, coordinate_word, order_word]
  # Output: saves coordinate word to address node_pointer, 
  # and order_word to address node_pointer+1
  #
  dup movdn.5 
  exec.SaveCoordinate
  exec.SaveOrder
end

proc.UpdateNode
  # Inputs: [node_pointer, coordinate_word, order_word]
  # Output: saves coordinate word to address node_pointer, 
  # and order_word to address node_pointer+1
  #
  dup movdn.5 
  exec.UpdateCoordinate
  exec.UpdateOrder
end

proc.InitTree
  # Inputs:  [...]
  # Outputs: [...]
  #
  # Comments: Initialized rbBST tree by creating a special first node
  # With color and parent pointer set to special value of 2
  # 
  push.0.0.0.0.0.0.0.2                         # [2,0,0,0,0,0,0,0, ...]
  push.0 exec.getNodePointer exec.SaveNode     
end

proc.getCoordinates
  # Inputs:  [node_pointer, ...]
  # Outputs: [color, Parent_pointer, L_child_pointer, R_child_pointer, ...]
  # 
  push.0.0.0.0 
  movup.4 mem_loadw             # Load node Coordinates from memory
end

proc.getColorFromCoordinates
  # Inputs:  [color, Parent_pointer, L_child_pointer, R_child_pointer, ...]
  # Outputs: [color, ...]
  # 
  movdn.3         # Move color to bottom of current word
  drop drop drop  # Drop unnecessary pointer data
end

proc.getChildrenFromCoordinates
  # Inputs:  [color, Parent_pointer, L_child_pointer, R_child_pointer, ...]
  # Outputs: [L_child_pointer, R_child_pointer, ...]
  # 
  drop drop
end

proc.getOrder
  # Inputs:  [node_pointer, ...]
  # Outputs: [quantity, price, time, orderID, ...]
  # 
  push.0.0.0.0 movup.4 push.1 add mem_loadw  # Load node Order from memory
end

proc.getChangeFlag
  # Inputs:  [node_pointer, ...]
  # Outputs: [change_flag, ...]
  #
  push.2 add mem_load
end

proc.LoadNode
  # Inputs: [node_pointer, ...]
  # Output: [coordinate_word, order_word]
  #
  dup exec.getOrder
  movup.4
  dup exec.getCoordinates
  movup.4 
  exec.getChangeFlag
end

proc.PrintAllNodesEssential
  # Inputs: [...]
  # Output: [N, coordinate_word_N, price_N, ..., 2, coordinate_word_2, price_2, 1, coordinate_word_3, price_3, ... ]
  #
  push.0 dup                            # [0,0,....]
  mem_load.0 lt                         # [isLessThanCreationNumber_bool, 0, ...]
  while.true
     push.1 add dup                     # [j++, j++, ...]
     exec.getNodePointer                # [node_pointer, j++, ...]
     dup exec.getOrder                  # [order_word, node_pointer, j++, ...]
     drop swap drop swap drop           # [order_price, node_pointer, j++, ...]
     swap exec.getCoordinates           # [coordinate_word, order_price, j++, ...]
     movup.5 dup                        # [j++, j++, coordinate_word, order_price, j++, ...]
     exec.getNodePointer swap           # [j++, node_pointer, coordinate_word, order_price, j++, ...]
     dup mem_load.0 lt                  # [moreNodes_bool, j++, node_pointer, coordinate_word, order_price, j++, ...]
  end
  drop
end

proc.PrintAllNodes
  # Inputs: [...]
  # Output: [N, coordinate_word_N, order_word_N, ..., 2, coordinate_word_2, order_word_2, 1, coordinate_word_3, order_word_3, ... ]
  #
  push.0 dup                            # [0,0,....]
  mem_load.0 lt                         # [isLessThanCreationNumber_bool, 0, ...]
  while.true
     push.1 add dup                     # [j++, j++, ...]
     exec.getNodePointer exec.LoadNode  # [node_change_flag, node_coordinate_word, node_order_word, j++, ...]
     drop movup.8 dup                   # [j++, j++, node_coordinate_word, node_order_word, ...]
     exec.getNodePointer swap           # [j++, node_pointer, node_coordinate_word, node_order_word, ...]
     dup mem_load.0 lt                  # [moreNodes_bool, j++, node_pointer, node_coordinate_word, node_order_word, ...]
  end
  drop
end

proc.PrintChangeLog
  # Inputs: [...]
  # Output: [N, coordinate_word_N, order_word_N, ..., 2, coordinate_word_2, order_word_2, 1, coordinate_word_3, order_word_3, ... ]
  #
  # Comments: Prints all node data only for orders whose change flag has changed
  #
  push.0 dup                           # [0,0,....]
  mem_load.0 lt                       # [isLessThanCreationNumber_bool, 0, ...]
  while.true
    push.1 add dup                     # [j++, j++, ...]
    exec.getNodePointer                # [node_pointer, j++, ...] 
    dup exec.getChangeFlag             # [node_change_flag, node_pointer, j++, ...]
    if.true 
      exec.LoadNode drop               # [node_coordinate_word, node_order_word, j++, ...]
      movup.8 dup                      # [j++, j++, node_coordinate_word, node_order_word, ...]
      exec.getNodePointer swap         # [j++, node_pointer, node_coordinate_word, node_order_word, ...]
    else 
      drop
    end                
    dup mem_load.0 lt                  # [moreNodes_bool, j++, node_pointer, node_coordinate_word, node_order_word, ...]
  end
  drop
end

proc.CompareOrders
  # Input:   [Order_word_A, Order_Word_B, ...]
  # Outputs: [compare_bool, ...]
  #
  # Comment: compare_bool = 0 (1) if Order_A < Order B (Order_A > Order B)
  #
  # Order_A > Order_B if ( (price_A > price_B) or ((price_A==price_B) and (time_A > time_B)) )
  #
  ### COMPARE PRICES ###
  dup.5                      # Duplicate Price_B  
  dup.2                      # Duplicate Price_A
  lt                         # Check Price_B < Price_A ?
  if.true                    # Price_B < Price_A
    dropw dropw push.1       # Push 1 to signal result Order_A > Order_B
  else
    dup.5 dup.2 neq          # Duplicate Price_B, Price_A, and check for equality
    if.true                  # Price_A < Price_B 
      dropw dropw push.0     # Push 0 to signal result Order_B > Order_A
    else                     # Price_A = Price_B
      dup.6 dup.3            # Duplicate Time_B and Time_A 
      lt                     # Check Time_B < Time_A ?
      if.true                # Time_B < Time_A
        dropw dropw push.1   # Push 1 to signal result Order_A > Order_B
      else                   # Time_B > Time_A
        dropw dropw push.0   # Push 0 to signal result Order_A < Order_B
      end 
    end 
  end 
end

proc.setLeftChildToParent
  # Inputs:  [Parent_pointer, New_Child_pointer, ...]
  # Outputs: [...]
  #
  # Comments: Whithin P_coordinates: L_child_pointer -> New_Child_pointer
  #
  dup exec.getCoordinates    # Duplicate P_pointer and load coordinates     [___, ___, Lchild_pointer, ___, parent_pointer, new_Lchild_pointer, ...]
  movup.5                    # Move new Lchild to the top of the stack      [new_Lchild_pointer, ___, ___, Lchild_pointer, ___, parent_pointer, ...]
  swap.3 drop                # Swap with old L_child pointer                [ ___, ___, new_Lchild_pointer, ___, parent_pointer, ...]       
  movup.4                    # Move P_pointer to the top of the stack       [parent_pointer,  ___, ___, new_Lchild_pointer, ___, ...]
  dup exec.SaveChangeFlag    # Save change flag                             [parent_pointer,  ___, ___, new_Lchild_pointer, ___, ...]
  exec.SaveCoordinate        # Save updated Parent coordinates              [...]
end

proc.setRightChildToParent
  # Inputs:  [Parent_pointer, New_Child_pointer, ...]
  # Outputs: [...]
  #
  # Comments: Whithin P_coordinates: L_child_pointer -> New_Child_pointer
  #
  dup exec.getCoordinates    # Duplicate P_pointer and load coordinates     [___, ___, ___, Rchild_pointer, parent_pointer, new_Lchild_pointer, ...]
  movup.5                    # Move new Rchild to the top of the stack      [new_child_pointer, ___, ___, ___, Rchild_pointer, parent_pointer, ...]
  swap.4 drop                # Swap with old Rchild pointer                 [___, ___, ___, new_child_pointer, parent_pointer, ...]       
  movup.4                    # Move P_pointer to the top of the stack       [parent_pointer,  ___, ___, ___, new_child_pointer, ...]
  dup exec.SaveChangeFlag    # Save change flag                             [parent_pointer,  ___, ___, ___, new_child_pointer, ...]
  exec.SaveCoordinate        # Save updated Parent coordinates              [...]
end

proc.UpdateChildInParent
  # Inputs: [Parent_pointer, Child_Pointer, ...]
  # Output: [...]
  #
  # Comments: Checks if child is L or R and updates the corresponding pointer
  #
  dup exec.SaveChangeFlag              # Save change flag              [Parent_pointer, Child_Pointer, ...]
  dup.1 exec.getOrder                  # Load child order              [child_order_word, Parent_pointer, Child_Pointer, ...]
  dup.4 exec.getOrder                  # Load parent order             [parent_order_word, child_order_word, Parent_pointer, Child_Pointer, ...]
  exec.CompareOrders                   # Compare Parent and Child      [isParentGreaterThanChild_bool, Parent_pointer, Child_Pointer, ...]
  if.true                              
    exec.setLeftChildToParent 
  else
    exec.setRightChildToParent
  end
end

proc.UpdateParentInChild
  # Inputs: [Parent_pointer, Child_Pointer, ...]
  # Output: [ ...]
  #
  # Comments:  Sets Parent_pointer as the new parent of Child 
  #
  dup.1 exec.SaveChangeFlag # Save change flag
  dup.1 exec.getCoordinates # Load Child coordinates                   [           ____, OLD_parent_pointer,               ____, ____, Parent_pointer, Child_Pointer, ...]
  movup.4                   # Move Parent_pointer to top of the stack  [ Parent_pointer,               ____, OLD_parent_pointer, ____,           ____, Child_Pointer, ...]
  swap.2 drop               # Update parent pointer                    [           ____,     Parent_pointer,               ____, ____,  Child_Pointer, ...]
  movup.4                   # Move Child_pointer to top of the stack   [  Child_Pointer,               ____,     Parent_pointer, ____,           ____, ...]
  exec.SaveCoordinate       # Save updated coordinates                 [ ...]  
end

proc.HasChildren
  # Inputs:  [ node_pointer, ...]
  # Outputs: [hasChildren_bool, ...]
  #
  # Comments: Returns terminal_bool=1 if node has children.
  # terminal_bool=0 otherwise
  #
  exec.getCoordinates
  exec.getChildrenFromCoordinates
  push.0 eq 
  if.true
    push.0 eq 
    if.true
      push.0
    else
      push.1
    end 
  else
    drop push.1
  end
end

proc.FindParent
  # Inputs:  [new_order_word, ...]
  # Outputs: [parent_node_pointer, new_order_wordA, ...]
  #
  push.1 exec.getNodePointer loc_store.3  # Initialize Temp Pointer To Tree Root   [new_order_word, ...]
  push.1                                  # Enter while loop                       [1, new_order_word, ...]
  while.true
    ### COMPARE ###
    dupw                      # Duplicate new order word                           [new_order_word, new_order_word, ...]
    loc_load.3 exec.getOrder  # Load Temp Parent Order                             [temp_order_word, new_order_word, new_order_word, ...]
    exec.CompareOrders        # Compare temp to new (returns 1 if parent>new)      [isTempOrderGreater_bool, new_order_word, ...]

    ### LOAD TEMP's CHILDREN ###
    loc_load.3 exec.getCoordinates       # Get coordinates of temp order           [temp_coordinate_word, isTempOrderGreater_bool, new_order_word, ...]
    exec.getChildrenFromCoordinates      # Get temp order child pointers           [temp_Lchild_pointer, temp_Rchild_pointer, isTempOrderGreater_bool, new_order_word, ...]

    movup.2                   # Get order compare back on top of stack             [isTempOrderGreater_bool, temp_Lchild_pointer, temp_Rchild_pointer, new_order_word, ...]
    if.true
      swap drop               # Isolate Left child pointer address                 [temp_Lchild_pointer, new_order_word, ...]
    else
      drop                   # Isolate Right child pointer address                 [temp_Rchild_pointer, new_order_word, ...]
    end

    dup push.0 neq            # Check if child is not NIL                          [isChildNotNIL_bool, temp_Xchild_pointer, new_order_word, ...]
    if.true
      loc_store.3             # Update temp parent pointer                         [new_order_word, ...]
      push.1                  # Continue while loop                                [1, new_order_word, ...]
    else
      drop push.0             # Child slot is empty. Insert node here              [0, new_order_word, ...]
    end
  end
  loc_load.3                  # Return proper parent in tree                       [temp_parent_pointer, new_order_word, ...]
end

proc.getParentPointer
  # Inputs:  [node_pointer, ...]
  # Outputs: [parent_pointer, ...]
  #
  # Comments: Gets parent pointer
  # 
  exec.getCoordinates          # Loads node coordinates       [___, parent_pointer, ___, ___, ...]
  drop swap drop swap drop     # Isolates Parent pointer      [parent_pointer, ...]
end

proc.getUnclePointer
  # Inputs:  [node_pointer, ...]
  # Outputs: [uncle_pointer, ...]
  #
  # Comments: Gets uncle pointer
  #
  exec.getParentPointer dup         # Retrieves parent pointer and dups  [     parent_pointer, parent_pointer, ...]
  exec.getParentPointer             # Retrieves pointer to grandparent   [grandparent_pointer, ...]
  exec.getCoordinates               # Loads grandparent coordinates      [____, ____, relatedA_pointer, relatedB_pointer, parent_pointer, ...]
  drop drop                         # Drop unnecessary fields            [relatedA_pointer, relatedB_pointer, parent_pointer, ...]
  movup.2 dup.1 eq                  # Check if relatedA=parent           [isAparent_bool, relatedA_pointer, relatedB_pointer, ...] 
  if.true
    drop                            # RelatedB is uncle              
  else
    swap drop                       # RelatedA is uncle
  end                               # [uncle_pointer,  ...]
end

proc.isNIL
  # Inputs:  [node_pointer, ...]
  # Outputs: [isNIL_bool, ...]
  #
  # Comments: Gets uncle pointer
  #  
  exec.getOrder                        # Load Order                       [order_quantity, order_price, order_time, order_index, ...] 
  push.0 eq                            # Is quantity zero                 [isQuantityZero_bool, order_price, order_time, order_index, ...]
  swap push.0 eq and                   # Are price&quantity zero          [isPriceQuantityZero_bool, order_time, order_index, ...]
  swap push.0 eq and                   # Are price&quantity&time zero     [isTimePriceQuantityZero_bool, order_index, ...]
  swap push.0 eq and                   # Are price&quantity&time&idx zero [isIdxTimePriceQuantityZero_bool, ...]
end

proc.getColor
  # Inputs:  [node_pointer, ...]
  # Outputs: [node_color, ...]
  #
  # Comments: Returns color of node at node_pointer
  #
  exec.getCoordinates exec.getColorFromCoordinates
end

proc.setColor
  # Inputs: [node_pointer, color_bool, ...]
  # Output: [...]
  #
  # Comments: Sets color of node addressed by node_pointer
  #           to the color specified by color_bool
  #
  dup exec.SaveChangeFlag    # Save change flag
  dup exec.getCoordinates    # Load node_pointer coordinates                   [  node_color,        ___, ___, ___, node_pointer, color_bool, ...]
  movup.5                    # Move color_bool to top of stack                 [color_bool, node_color, ___, ___, ___, node_pointer, ...]
  swap drop movup.4          # Swap colors and move node_pointer top of stack  [node_pointer, color_bool, ___, ___, ___, ...]
  exec.SaveCoordinate
end

proc.isRoot
  # Inputs:  [node_pointer, ...]
  # Outputs: [isRoot_bool, ...]
  #
  # Comments: Checks if node is root of the tree
  #
  exec.getParentPointer exec.getColor    # Get parent color      [parent_color, ...]
  push.2 eq                              # Is Color Init value 2 [isColorInit_bool,...]
end

proc.getRootPointer 
  push.0 exec.getNodePointer exec.getCoordinates exec.getChildrenFromCoordinates
  dup push.0 eq 
  if.true 
    drop 
  else 
    swap drop
  end
end

proc.isUncleNIL
  # Inputs:  [node_pointer, ...]
  # Outputs: [isUncleNIL_bool, ...]
  #
  # Comments: Checks if Uncle of node is NIL
  #
  exec.getUnclePointer exec.isNIL
end

proc.isLeftChild
  # Inputs:  [node_pointer, ...]
  # Outputs: [isLeftChild_bool]
  #
  # Comments: Checks if node is a Left child of its parent
  #
  dup exec.isRoot not            # Confirm node isn't root   [isRoot_bool, node_pointer, ...]
  if.true
    dup exec.getParentPointer    # Loads pointer to parent   [parent_pointer, node_pointer, ...]
    exec.getCoordinates          # Loads parent coordiantes  [___, ___, parent_Lchild_pointer, parent_Rchild_pointer, node_pointer, ...]
    drop drop swap drop          # Drop unnecessary fields   [parent_Lchild_pointer, node_pointer, ...]
    eq                           # Check if node is Lchild   [isLeftChild_bool]
  else
    drop push.0  
  end            
end